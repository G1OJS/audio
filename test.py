class Encoder:
    def __init__(self):
        self.C2M = {
        'A':'.-',   'B':'-...',  'C':'-.-.',  'D':'-..',  'E':'.',     'F':'..-.',  'G':'--.',  'H':'....',
        'I':'..',   'J':'.---',  'K':'-.-',   'L':'.-..', 'M':'--',    'N':'-.',    'O':'---',  'P':'.--.',
        'Q':'--.-', 'R':'.-.',   'S':'...',   'T':'-',    'U':'..-',   'V':'...-',  'W':'.--',  'X':'-..-',
        'Y':'-.--',  'Z':'--..',

        '0':'-----', '1':'.----', '2':'..---', '3':'...--',
        '4':'....-', '5':'.....', '6':'-....', '7':'--...',
        '8':'---..', '9':'----.'
        }
    def encode_syms(self, sig, bits_per_dit = 5):
        syms = ['-','.',' ','/']
        tbl = [[1,1,1,0],[1,0],[0,0,0],[0,0,0,0,0,0,0]]
        bits = [tbl[syms.index(sym)] for sym in sig]
        bits = [b for bb in bits for b in bb]
        return [b for b in bits for i in range(bits_per_dit)]
        
    def encode_chars(self, text):
        syms = []
        words = text.split(' ')
        for wd in words:
            syms.append(' '.join([self.C2M.get(c) for c in wd]))
        return '/'.join(syms)

class Decoder:
    def __init__(self):
        self.M2C = {
        '.-':'A',   '-...':'B',  '-.-.':'C',  '-..':'D',   '.':'E',    '..-.':'F',  '--.':'G', '....':'H',
        '..':'I',   '.---':'J',  '-.-':'K',   '.-..':'L',  '--':'M',   '-.':'N',    '---':'O', '.--.':'P',
        '--.-':'Q', '.-.':'R',   '...':'S',   '-': 'T',    '..-':'U',  '...-':'V',  '.--':'W', '-..-':'X',
        '-.--':'Y', '--..':'Z',
        '-----': '0', '.----': '1', '..---': '2', '...--': '3',
        '....-': '4', '.....': '5', '-....': '6', '--...': '7',
        '---..': '8', '----.': '9'
        }

    def score_segment(self, bits, start, length, expected):
        seg = bits[start:start+length]
        if len(seg) < length:
            return -1e9  # impossible
        # expected = 1 for tone, 0 for silence
        matches = sum(1 for b in seg if b == expected)
        mismatches = length - matches
        return matches - 2*mismatches   # penalize wrong polarity harder

    def viterbi_bits(self, bits, T):
        """
        Viterbi over a bitstream generated by Encoder.encode_syms().
        Encoder model:
          '.'  -> 1T ON  + 1T OFF
          '-'  -> 3T ON  + 1T OFF
          ' '  -> 3T OFF (letter gap marker)
          '/'  -> 7T OFF (word gap marker)

        Because every symbol already includes 1T OFF, the *extra* silence needed is:
          letter gap total 3T => extra 2T OFF (in addition to the 1T OFF already emitted)
          word gap total 7T   => extra 6T OFF
        """
        N = len(bits)
        NEG_INF = -10**18

        # One state is enough here: we always "place a token" that consumes time.
        # Tokens: DOT, DASH, LETTER_GAP_EXTRA, WORD_GAP_EXTRA
        best = [NEG_INF] * (N + 1)
        back = [None] * (N + 1)

        best[0] = 0

        def score_run(start, length, expected):
            return self.score_segment(bits, start, length, expected)

        for t in range(N + 1):
            if best[t] <= NEG_INF/2:
                continue

            # --- DOT: 1T ON + 1T OFF ---
            L = 2 * T
            if t + L <= N:
                sc = score_run(t, T, 1) + score_run(t + T, T, 0)
                nt = t + L
                cand = best[t] + sc
                if cand > best[nt]:
                    best[nt] = cand
                    back[nt] = (t, ".")

            # --- DASH: 3T ON + 1T OFF ---
            L = 4 * T
            if t + L <= N:
                sc = score_run(t, 3*T, 1) + score_run(t + 3*T, T, 0)
                nt = t + L
                cand = best[t] + sc
                if cand > best[nt]:
                    best[nt] = cand
                    back[nt] = (t, "-")

            # --- LETTER GAP EXTRA: +2T OFF, emits '|' ---
            L = 2 * T
            if t + L <= N:
                sc = score_run(t, L, 0)
                nt = t + L
                cand = best[t] + sc
                if cand > best[nt]:
                    best[nt] = cand
                    back[nt] = (t, "|")

            # --- WORD GAP EXTRA: +6T OFF, emits '/' ---
            L = 6 * T
            if t + L <= N:
                sc = score_run(t, L, 0)
                nt = t + L
                cand = best[t] + sc
                if cand > best[nt]:
                    best[nt] = cand
                    back[nt] = (t, "/")

        # Termination: choose best reachable endpoint (not necessarily exactly N)
        end_t = max(range(N + 1), key=lambda i: best[i])
        end_score = best[end_t]

        seq = self.backtrack_1d(back, end_t)
        return seq, end_score

    def backtrack_1d(self, back, end_t):
        seq = []
        t = end_t
        while t > 0:
            entry = back[t]
            if entry is None:
                break
            prev_t, sym = entry
            seq.append(sym)
            t = prev_t
        return "".join(reversed(seq))


test_sig = 'CQ DE G1OJS'
encoder = Encoder()  
syms = encoder.encode_chars(test_sig)
print(syms)
code = encoder.encode_syms(syms)
print(code)

best_global = None
best_score = -1e18

decoder = Decoder()
for T in range(3,9):
    seq, score = decoder.viterbi_bits(code, T)
    if score > best_score:
        best_score = score
        best_global = seq

print(best_global)

